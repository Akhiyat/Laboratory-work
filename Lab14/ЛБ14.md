# Титульный лист

РОССИЙСКИЙ УНИВЕРСИТЕТ ДРУЖБЫ НАРОДОВ

Факультет физико-математических и естественных наук









**Лабораторная работа 14**

По дисциплине "Операционные системы"













Выполнил:

Студент группы НПВбм-01-19

Студенческий билет №: 1032193844 

Саидов Ахият Магомадович

Руководитель: Валиева Татьяна Рефатовна























Москва 2023



# Цель работы

Приобрести простейшие навыки разработки, анализа, тестирования и отладки приложений в ОС типа UNIX/Linux на примере создания на языке программирования С калькулятора с простейшими функциями.

# Начало работы

1. В домашнем каталоге создадим подкаталог _~/work/os/lab_prog_.

   ![](https://github.com/Akhiyat/Laboratory-work/blob/main/Lab14/screencast/%D0%A0%D0%B8%D1%811.JPG?raw=true)

   _Рисунок 1_

2. Создадим в нём файлы: _calculate.h, calculate.c, main.c._

   ![](https://github.com/Akhiyat/Laboratory-work/blob/main/Lab14/screencast/%D0%A0%D0%B8%D1%812.JPG?raw=true)

   _Рисунок 2_

   Реализация функций калькулятора в файле _calculate.с_:

   ![](https://github.com/Akhiyat/Laboratory-work/blob/main/Lab14/screencast/%D0%A0%D0%B8%D1%813.JPG?raw=true)

   _Рисунок 3_

   Интерфейсный файл _calculate.h_, описывающий формат вызова функциикалькулятора:

   ![](https://github.com/Akhiyat/Laboratory-work/blob/main/Lab14/screencast/%D0%A0%D0%B8%D1%814.JPG?raw=true)

   _Рисунок 4_

   Основной файл _main.c_, реализующий интерфейс пользователя к калькулятору:

   ![](https://github.com/Akhiyat/Laboratory-work/blob/main/Lab14/screencast/%D0%A0%D0%B8%D1%815.JPG?raw=true)

   _Рисунок 5_

3. Выполним компиляцию программы посредством `gcc`.

   ![](https://github.com/Akhiyat/Laboratory-work/blob/main/Lab14/screencast/%D0%A0%D0%B8%D1%816.JPG?raw=true)

   _Рисунок 6_

4. При необходимости исправим синтаксические ошибки.

5. Создадим _Makefile_ со следующим содержанием:

   ![](https://github.com/Akhiyat/Laboratory-work/blob/main/Lab14/screencast/%D0%A0%D0%B8%D1%817.JPG?raw=true)

   _Рисунок 7_

6. С помощью gdb выполните отладку программы calcul (перед использованием gdb исправьте _Makefile_): 

   * Запустите отладчик _GDB_, загрузив в него программу для отладки: 

     `gdb ./calcul` 

     ![](https://github.com/Akhiyat/Laboratory-work/blob/main/Lab14/screencast/%D0%A0%D0%B8%D1%818.JPG?raw=true)

     _Рисунок 8_

   * Для запуска программы внутри отладчика введите команду _run_: 

     `run` 

     ![](https://github.com/Akhiyat/Laboratory-work/blob/main/Lab14/screencast/%D0%A0%D0%B8%D1%819.JPG?raw=true)

     _Рисунок 9_

   * Для постраничного (по 9 строк) просмотра исходного код используйте команду _list_:

     `list`

     ![](https://github.com/Akhiyat/Laboratory-work/blob/main/Lab14/screencast/%D0%A0%D0%B8%D1%8110.JPG?raw=true)

     _Рисунок 10_

   * Для просмотра строк с 12 по 15 основного файла используйте _list_ с параметрами: 

     `list 12,15` 

     ![](https://github.com/Akhiyat/Laboratory-work/blob/main/Lab14/screencast/%D0%A0%D0%B8%D1%8111.JPG?raw=true)

     _Рисунок 11_

   * Для просмотра определённых строк не основного файла используйте _list_ с параметрами: 

     `list calculate.c:20,29` 

     ![](https://github.com/Akhiyat/Laboratory-work/blob/main/Lab14/screencast/%D0%A0%D0%B8%D1%8112.JPG?raw=true)

     _Рисунок 12_

   * Установите точку останова в файле _calculate.c_ на строке номер 21: 

     `list calculate.c:20,27` 

     `break 21` 

     ![](https://github.com/Akhiyat/Laboratory-work/blob/main/Lab14/screencast/%D0%A0%D0%B8%D1%8113.JPG?raw=true)

     _Рисунок 13_

   * Выведите информацию об имеющихся в проекте точка останова: 

     `info breakpoints` 

     ![](https://github.com/Akhiyat/Laboratory-work/blob/main/Lab14/screencast/%D0%A0%D0%B8%D1%8114.JPG?raw=true)

     _Рисунок 14_

   * Запустите программу внутри отладчика и убедитесь, что программа остановится в момент прохождения точки останова: 

     `run`

     `5` 

     `-`

     `backtrace `

     ![](https://github.com/Akhiyat/Laboratory-work/blob/main/Lab14/screencast/%D0%A0%D0%B8%D1%8115.JPG?raw=true)

     _Рисунок 15_

   * Отладчик выдаст следующую информацию: 

     `#0 Calculate (Numeral=5, Operation=0x7fffffffd280 "-") `

     `at calculate.c:21 `

     `#1 0x0000000000400b2b in main () at main.c:17 `

     а команда _backtrace_ покажет весь стек вызываемых функций от начала программы до текущего места. 

   * Посмотрите, чему равно на этом этапе значение переменной _Numeral_, введя: 

     `print Numeral`

     ![](https://github.com/Akhiyat/Laboratory-work/blob/main/Lab14/screencast/%D0%A0%D0%B8%D1%8116.JPG?raw=true)

     _Рисунок 16_

     На экран должно быть выведено число 5. 

   * Сравните с результатом вывода на экран после использования команды: 

     `display Numeral`

     ![](https://github.com/Akhiyat/Laboratory-work/blob/main/Lab14/screencast/%D0%A0%D0%B8%D1%8117.JPG?raw=true)

     _Рисунок 17_

   *  Уберите точки останова: 

     `info breakpoints` 

     `delete 1`

     ![](https://github.com/Akhiyat/Laboratory-work/blob/main/Lab14/screencast/%D0%A0%D0%B8%D1%8118.JPG?raw=true)

     _Рисунок 18_

7. С помощью утилиты splint попробуем проанализировать коды файлов _calculate.c_ и _main.c_.

   ![](https://github.com/Akhiyat/Laboratory-work/blob/main/Lab14/screencast/%D0%A0%D0%B8%D1%8119.JPG?raw=true)

   _Рисунок 19_

   ![](https://github.com/Akhiyat/Laboratory-work/blob/main/Lab14/screencast/%D0%A0%D0%B8%D1%8120.JPG?raw=true)

   _Рисунок 20_

# Вывод 

Мы приобрели простейшие навыки разработки, анализа, тестирования и отладки приложений в ОС типа UNIX/Linux на примере создания на языке программирования С калькулятора с простейшими функциями.

# Контрольные вопросы

1. Для этого есть команда man и предлагающиеся к ней файлы.

2. Кодировка, Компиляция, Тест.

3. Это расширения файлов.

4. Программа gcc, которая интерпретирует к определенному языку программирования аргументы командной строки и определяет запуск нужного компилятора для нужного файла

5. Для компиляции группы файлов. Собрания из них программы, и последующего удаления.

6. `program: main.o lib.o` 

   `cc -o program main.o lib.o` 

   `main.o lib.o: defines.h` 

   ​	В имени второй цели указаны два файла и для этой же цели не указана команда компиляции. Кроме того, нигде явно не указана зависимость объектных 14 файлов от _«*.c»_-файлов. Дело в том, что программа _make_ имеет предопределённые правила для получения файлов с определёнными расширениями. Так, для цели-объектного файла (расширение _«.o»_) при обнаружении соответствующего файла с расширением _«.c»_ будет вызван компилятор _«сс -с»_ с указанием в параметрах этого _«.c»_-файла и всех файлов-зависимостей.

7. Программы для отладки нужны для нахождения ошибок в программе. Для их использования надо скомпилировать программу таким образом, чтобы отладочная информация содержалась в конечном бинарном файле.

8. * _backtrace_ – выводит весь путь к текущей точке останова, то есть названия всех функций, начиная от main(); иными словами, выводит весь стек функций; 
   * _break_ – устанавливает точку останова; параметром может быть номер строки или название функции; 
   * _clear_ – удаляет все точки останова на текущем уровне стека (то есть в текущей функции); 
   * _continue_ – продолжает выполнение программы от текущей точки до конца; 
   * _delete_ – удаляет точку останова или контрольное выражение; 
   * _display_ – добавляет выражение в список выражений, значения которых отображаются каждый раз при остановке программы; 
   * _finish_ – выполняет программу до выхода из текущей функции; отображает возвращаемое значение,если такое имеется; 
   * _info breakpoints_ – выводит список всех имеющихся точек останова; 
   * _info watchpoints_ – выводит список всех имеющихся контрольных выражений; 
   * _list_ – выводит исходный код; в качестве параметра передаются название файла исходного кода, затем, через двоеточие, номер начальной и конечной строки;
   * _next_ – пошаговое выполнение программы, но, в отличие от команды step, не выполняет пошагово вызываемые функции; 
   * _print_ – выводит значение какого-либо выражения (выражение передаётся в качестве параметра); 
   * _run_ – запускает программу на выполнение; 
   * _set_ – устанавливает новое значение переменной step – пошаговое выполнение программы; 
   * _watch_ – устанавливает контрольное выражение, программа остановится, как только значение контрольного выражения изменится;

9. * _gdb –silent ./calcul_
   * _run 12. list_ 
   * _backtrace_ 
   * _breakpoints_ 
   * _print Numeral_ 
   * _Splint_

10. Консоль выводит ошибку с номером строки и ошибочным сегментом, но при этом есть возможность выполнить программу сразу.

11. * Правильный синтаксис
    * Наличие комментариев 
    * Разбиение большой сложной программы на несколько сегментов попроще.

12. _Split_ – разбиение файла на меньшие, определённого размера. Может разбивать текстовые файлы по строкам и любые – по байтам. По умолчанию читает со стандартного ввода и создает файлы с именами вида _xaa, xab_ и т.д. По умолчанию разбиение идёт по 1000 строк в файле.
